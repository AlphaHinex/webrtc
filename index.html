<!DOCTYPE html>
<html>
<head>
<script src="latest-v2.js"></script>
</head>

<body>

<div id="localVideo" muted></div>
<div id="remoteVideos"></div>
<textarea id="chatText" cols="30" rows="10" disabled="true"></textarea>
<button id="chatSend" disabled="true" onclick="sendMsg()">send</button>
<div id="chatArea"></div>
<div id="remotes"></div>

<script>
var webrtc = new SimpleWebRTC({
  localVideoEl: 'localVideo',
  remoteVideosEl: 'remoteVideos',
  autoRequestMedia: true
});

webrtc.on('readyToCall', function () {
  webrtc.joinRoom('hinex');
  document.querySelector('#chatText').disabled = false;
  document.querySelector('#chatSend').disabled = false;
});

var sendMsg = function() {
  webrtc.sendDirectlyToAll('text chat', 'chat', document.querySelector('#chatText').value);
};

webrtc.on('channelMessage', function(peer, label, data) {
  if (data.type === 'chat') {
    console.debug('Received message: %s from %s', data.payload, peer.id);
  }
  var area = document.querySelector('#chatArea');
  area.innerHTML = area.innerHTML + '<br/>' + data.payload;
});

webrtc.on('createdPeer', function(peer) {
  console.debug('createdPeer', peer);
  var remotes = document.getElementById('remotes');
  if (!remotes) return;
  var container = document.createElement('div');
  container.id = 'container_' + webrtc.getDomId(peer);

  var peername = document.createElement('div');
  peername.appendChild(document.createTextNode('Peer: ' + peer.id));
  container.appendChild(peername);

  var filelist = document.createElement('ul');
  container.appendChild(filelist);

  var fileinput = document.createElement('input');
  fileinput.type = 'file';

  fileinput.addEventListener('change', function() {
    fileinput.disabled = true;

    var file = fileinput.files[0];
    var sender = peer.sendFile(file);

    var item = document.createElement('li');

    var span = document.createElement('span');
    span.appendChild(document.createTextNode(file.name));
    item.appendChild(span);

    span = document.createElement('span');
    span.appendChild(document.createTextNode(file.size + 'bytes'));
    item.appendChild(span);

    var sendProgress = document.createElement('progress');
    sendProgress.max = file.size;
    item.appendChild(sendProgress);

    sender.on('progress', function(bytesSent) {
      sendProgress.value = bytesSent;
    });

    sender.on('sentFile', function() {
      item.appendChild(document.createTextNode('sent'));
      fileinput.removeAttribute('disabled');
    });

    // receiver has actually received the file
    sender.on('complete', function() {
      // safe to disconnect now
    });
    filelist.appendChild(item);
  }, false);
  fileinput.disabled = 'disabled';
  container.appendChild(fileinput);

  if (peer && peer.pc) {
    var connstate = document.createElement('div');
    container.appendChild(connstate);
    peer.pc.on('iceConnectionStateChange', function(event) {
      var state = peer.pc.iceConnectionState;
      console.debug('state', state);
      switch (state) {
        case 'checking':
          connstate.innerText = 'Connection to peer ...';
          break;
        case 'connected':
        case 'completed':
          connstate.innerText = 'Connection established.';
          fileinput.removeAttribute('disabled');
          break;
        case 'disconnected':
          connstate.innerText = 'Disconnected.';
          break;
        case 'failed':
          console.debug('failed!');
          break;
        case 'closed':
          connstate.innerText = 'Connection closed.';
          fileinput.disabled = 'disabled';
          break;
      }
    });
  }
  remotes.appendChild(container);

  peer.on('fileTransfer', function(metadata, receiver) {
    console.debug('incoming filetransfer', metadata);
    var item = document.createElement('li');
    var span = document.createElement('span');
    span.appendChild(document.createTextNode(metadata.name));
    item.appendChild(span);

    span = document.createElement('span');
    span.appendChild(document.createTextNode(metadata.size + 'bytes'));
    item.appendChild(span);

    var receiveProgress = document.createElement('progress');
    receiveProgress.max = metadata.size;
    item.appendChild(receiveProgress);

    receiver.on('progress', function (bytesReceived) {
        receiveProgress.value = bytesReceived;
    });

    receiver.on('receivedFile', function(file, metadata) {
      console.debug('received file', metadata.name, metadata.size);
      var href = document.createElement('a');
      href.href = URL.createObjectURL(file);
      href.download = metadata.name;
      href.appendChild(document.createTextNode('download'));
      item.appendChild(href);

      receiver.channel.close();
    });
    filelist.appendChild(item);
  });
});

// local p2p/ice failure
webrtc.on('iceFailed', function (peer) {
  var connstate = document.querySelector('#container_' + webrtc.getDomId(peer) + ' .connectionstate');
  var fileinput = document.querySelector('#container_' + webrtc.getDomId(peer) + ' input');
  console.debug('local fail', connstate);
  if (connstate) {
    connstate.innerText = 'Connection failed.';
    fileinput.disabled = 'disabled';
  }
});

// remote p2p/ice failure
webrtc.on('connectivityError', function (peer) {
  var connstate = document.querySelector('#container_' + webrtc.getDomId(peer) + ' .connectionstate');
  var fileinput = document.querySelector('#container_' + webrtc.getDomId(peer) + ' input');
  console.debug('remote fail', connstate);
  if (connstate) {
    connstate.innerText = 'Connection failed.';
    fileinput.disabled = 'disabled';
  }
});
</script>

</body>

</html>
